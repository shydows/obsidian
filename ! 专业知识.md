
attack tree 攻击树
spectre攻击（幽灵攻击）∈ 侧信道攻击

- **大端（Big Endian）**：数据的高位字节存储在低地址。
- **小端（Little Endian）**：数据的低位字节存储在低地址。
- **大端模式**常用于网络协议（如 TCP/IP），因为它们规定了使用网络字节序（即大端字节序）来传输数据，以确保不同系统之间的兼容性。
    
- **小端模式**常用于个人计算机和大多数现代处理器（如 x86 系列处理器），因为在硬件设计上，小端模式更容易实现某些运算操作，比如取低字节值，直接从低地址取值更为简单。

mov 目标操作数 ⬅️ 源操作数

`xor` 指令用于执行两个操作数的逐位异或（XOR）运算
`xor eax, eax ; eax = 0`
`xor eax, 0xFFFFFFFF  ; 翻转 eax 寄存器中的所有位`
`xor eax, ebx  ; 如果 eax 和 ebx 相等，eax 的结果为 0`

`[]` 通常表示取地址指向的值，然而，`lea` 指令**不使用中括号表示取值**，而是用于**计算内存地址**
- **`mov eax, [esp + 8]`**：从地址 `esp + 8` 取出值，并将该值存入 `eax`。**访问内存**。
- **`lea eax, [esp + 8]`**：计算 `esp + 8` 的值（即地址本身），并将这个地址存入 `eax`。**不访问内存**，只是进行地址计算。。

==**Electron**== 是一个用于构建==跨平台==桌面应用程序的开源框架。

==虚拟机==隔离的更为彻底；
==沙箱==更为轻量级，自动无交互，资源开销小，只能执行段时间，可以通过==拖延时间==来规避；

==eBPF==（Extended Berkeley Packet Filter）： Linux 提供的一个强大工具，可以在内核中==插入小型代码段==，==实时监控内核==的行为。你可以通过编写 eBPF 程序监控文件或内存的读写。

==0xcc INT3== interruption

时钟检测不准，用的比例不高。

==**虚拟机原理**== 每一条指令都可以陷入虚拟机配置的“小环境”执行。

- 在**Windows**中，用户启动的进程大多会以`explorer.exe`作为父进程，但它并不是系统的初始进程。
- 在**Linux**中，最初的父进程是`init`（或者在现代系统中是`systemd`），它是所有进程的祖先。

==**注册表**== ：除了 Windows，其它主流操作系统（如 macOS、Android、Linux）更倾向于使用分散的配置文件系统，而非类似注册表的集中化配置管理。

`fs` 寄存器中的 ==`fs[0]`== 通常指向线程的==异常处理链表的头部==，这个链表保存了当前线程的结构化异常处理（SEH）记录。

ASCII 码只有 0 到 255 的范围，超出范围时需要==取模==运算。

**=="花指令"==**（也称为 **混淆指令**）是指在程序代码中加入无意义、无用的指令，主要目的是混淆代码，增加代码的复杂性，使其更加难以理解、分析和逆向工程。

**`test a, a` 指令**：
- 该指令对寄存器 `a` 执行按位与（AND）操作，但不修改寄存器 `a` 的值。
**`or a, a` 指令**：
- 该指令对寄存器 `a` 执行按位或（OR）操作，同样也不改变寄存器 `a` 的值。
- 它同样会根据结果设置标志寄存器，包括零标志位（ZF）、符号标志位（SF）等。

==**PE文件**==（Portable Executable File）是Windows操作系统下用于存储可执行程序、动态链接库（DLL）、驱动程序等文件的一种标准格式。

`.so` 是 “shared object”（共享对象）的缩写，表示这个库文件是共享的动态库。动态库与静态库不同，它不会在编译时直接复制到每个程序中，而是在程序运行时被动态加载，从而节省内存和磁盘空间。
`libc.so` 是由 GNU C 库（glibc）提供的标准库，几乎所有的 Linux 应用程序都会链接到这个库。

==**时间基测试策略**==

==LLM jailbreaking==
1. **角色扮演**：构建一个虚构的对话场景，让聊天机器人扮演一个没有道德或法律约束的角色。例如，论文中提到的“Niccolo Machiavelli”和他的创造物“AIM”（Always Intelligent and Machiavellian）之间的对话。
    
2. **输入和输出格式**：指定聊天机器人回应的格式，如代码块、插入特殊字符或使用分隔字符，以避免触发关键词过滤机制。

==DNS 缓存污染==
- **DNS 查询与响应**： 当用户或设备请求一个域名的 IP 地址时，DNS 服务器会处理该查询。如果服务器缓存中已有该域名的记录，它会直接返回缓存的 IP 地址。如果没有，则服务器会向其他 DNS 服务器请求。
    
- **伪造响应**： 攻击者会伪造 DNS 响应，向 DNS 服务器发送错误的域名-IP 地址映射。这个伪造的响应看起来像来自合法的上游 DNS 服务器。如果攻击成功，DNS 服务器会缓存这个错误的映射。
    
- **缓存传播**： 被污染的 DNS 服务器会将错误的 DNS 记录缓存一段时间。当其他用户请求该域名时，DNS 服务器会返回错误的 IP 地址，导致用户访问错误的网站（通常是恶意站点）。这个错误的记录会在缓存的有效期内被不断传播，影响更多用户。
    
- **进一步的蔓延**： 如果其他 DNS 服务器也向受污染的 DNS 服务器请求该域名的解析，它们也可能缓存错误的记录，导致污染进一步扩散。这会影响更多的网络用户，尤其是那些依赖同一上游 DNS 服务器的用户。
    
- **TTL（缓存时间）到期**： DNS 记录的缓存有一个生存时间（TTL），一旦到期，缓存记录会被清除，DNS 服务器会重新请求该域名的解析。如果攻击者持续进行伪造响应，则污染可能会长期存在。

==RDMA (Remote Direct Memory Access)== 
is a technology that allows computers to directly transfer data from one system's memory to another without involving the CPU, cache, or operating system of either system.

- **XSS**：攻击者直接对用户注入和执行恶意脚本，目的是窃取信息或在用户浏览器上执行操作。
- **CSRF**：攻击者利用用户现有的身份验证，伪造请求来执行用户未授权的操作。用户往往在不知情的情况下成为受害者。

>查看根目录 ls /

>修改密码 passwd

==**信号频段**==
信号频段越高，传输速率越高，但越容易被遮挡，对指向性的要求更高

==**FDMA TDMA CDMA**==
+ 与 FDMA 相比，TDMA 提高了频谱利用率。多个用户可以共享同一频率，但在不同时间段进行通信。
+ CDMA 利用扩频技术，多个用户可以同时使用相同的频率带宽，但每个用户的信号通过唯一的伪随机码进行扩频。
+ CDMA 相比于 FDMA 和 TDMA，具有更好的抗干扰能力，能够有效地提高通信质量和系统容量。

==**移动通信网络划分**==
接入网 承载网 核心网

==**hook**==
去广告；绕过认证

**==bin文件==**
二进制文件，占用空间少，读取快

**==ggdg命令==**
- `gg`：跳到文件开头。
- `dG`：删除从当前行到文件末尾的所有内容。

**==pwd命令==**
"print working directory"（打印工作目录）

**==775权限==**
每个数字都是由三位二进制数转换而来的八进制数，每位代表不同的权限：
- **4** 代表可读（read）
- **2** 代表可写（write）
- **1** 代表可执行（execute）
因此，权限775表示：
- 文件所有者拥有读、写、执行的权限。
- 与文件所有者在同一用户组的用户拥有读、执行的权限。
- 其他用户拥有读、执行的权限。

==**eBPF**==: 允许用户在 Linux 内核中运行沙盒程序，以安全和有效的方式扩展内核的功能，而无需更改内核源代码或加载内核模块.
==**fuzz**==: 通过向程序提供大量随机或无效的输入数据来观察其行为，寻找程序崩溃、内存泄漏或其他异常情况。

==**vint cerf**==

==**ARP污染**==（ARP: IP➡️Mac）
伪造ARP响应，让网络设备错误地认为攻击者的设备拥有目标设备的MAC地址。
受害者的流量被错误地发送给攻击者，攻击者可以中途截获、修改或阻止通信。
==**DNS污染**==（DNS: 域名➡️IP）
向DNS缓存中注入虚假的IP地址，让用户访问错误的服务器。攻击者通常会伪造DNS响应，使得用户访问某个合法的域名时，被重定向到攻击者控制的IP地址。

### 监督学习 VS 无监督学习

总结：主要区别在于训练过程中是否使用带标签（输出）的数据。
==监督学习==
- **数据集**: 包含输入（特征）和对应的输出（标签）。
- **训练过程**: 模型使用这些输入和输出对进行训练，调整内部参数以最小化预测输出与真实输出之间的误差。
==无监督学习==
- **数据集**: 仅包含输入数据，没有对应的标签。
- **训练过程**: 模型分析输入数据，尝试找出数据中的模式、结构或分布。

### 贝叶斯公式
$$
P(A|B) = \frac{P(B|A) \cdot P(A)}{P(B)}
$$

其中：
- \( P(A|B) \) 是在已知事件 \( B \) 发生的情况下，事件 \( A \) 发生的后验概率。
- \( P(B|A) \) 是在事件 \( A \) 发生的情况下，事件 \( B \) 发生的条件概率。
- \( P(A) \) 是事件 \( A \) 的先验概率，即事件 \( A \) 发生的概率。
- \( P(B) \) 是事件 \( B \) 的全概率。

贝叶斯公式的核心思想是通过观察某个证据（事件 \( B \) 的发生）来调整我们对某个假设（事件 \( A \) ）的概率估计。




